# Справочник Vue 3

https://ru.vuejs.org/guide/introduction.html

## Создание приложения

```
import { createApp } from 'vue'
// импорт корневого компонента App из однофайлового компонента
import App from './App.vue'

const app = createApp(App)
```

В функицию createApp обязательно должен быть передан корневой компонент,
который содержит в себе другие компоненты.


```
<div id="app"></div>

app.mount('#app')

```

Экземпляр приложения не будет ничего отрисовывать, пока не вызвать его метод .mount().

```
app.config.errorHandler = (err) => {
  /* обработка ошибки */
}
```

Экземпляр приложения предоставляет объект .config.

## Синтаксис шаблонов

### Текстовые интерполяции
​
```
<span>Сообщение: {{ msg }}</span>
```

### Сырой HTML
​
```
<p>Директива v-html: <span v-html="rawHtml"></span></p>
```

### Атрибуты

```
<div v-bind:id="dynamicId"></div>
```

```
<div :id="dynamicId"></div>
```

```
<!-- так же, как :id="id" -->
<div :id></div>

<!-- это также работает -->
<div v-bind:id></div>
```

### Булевы атрибуты

```
<button :disabled="isButtonDisabled">Кнопка</button>
```

Атрибут disabled будет добавляться, когда значение isButtonDisabled истинно. 
Он также будет добавляться, если значением будет пустая строка, для сохранения консистентности с <button disabled="">. 
При использовании других ложных значений атрибут будет опущен.

### Динамическая привязка нескольких атрибутов
​
```
data() {
  return {
    objectOfAttrs: {
      id: 'container',
      class: 'wrapper'
    }
  }
}
```

Можно привязать их все к одному элементу, используя v-bind без аргумента:

```
<div v-bind="objectOfAttrs"></div>
```

### Использование JavaScript-выражений

```
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

В шаблонах Vue выражения JavaScript можно использовать в следующих ситуациях:

- Внутри текстовых интерполяций (двойных фигурных скобок)
- В значении атрибутов директив Vue (специальные атрибуты, именуемые с v-)

Каждая привязка может содержать только одно выражение. 
Выражение — часть кода, которая может быть преобразована в значение. 

### Вызов функций
​
```
<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>
```

Функции, вызываемые в выражениях внутри привязки, будут вызываться каждый раз при обновлении компонента, 
поэтому НЕ ДОЛЖНЫ ИМЕТЬ НИКАКИХ ПОБОЧНЫХ ЭФФЕКТОВ, таких как изменение данных или запуск асинхронных операций.

### Ограничения доступа к глобальным объектам
​
Выражения в шаблонах находятся в «песочнице» и имеют доступ только к ограниченному списку глобальных свойств, 
таких как Math и Date.

### Директивы

Директивы — специальные атрибуты с префиксом `v-`.

```
<p v-if="seen">Сейчас меня видно</p>
```

Здесь директива `v-if` удаляет или вставляет на страницу элемент `<p>` на основании истинности выражения `seen`.

Другим примером может быть директива v-on, которая отслеживает события DOM.

```
<a v-on:click="doSomething"> ... </a>

<!-- сокращённая запись -->
<a @click="doSomething"> ... </a>
```

### Динамические аргументы
​
Можно использовать выражение JavaScript в аргументе директивы, для этого потребуется обернуть его в квадратные скобки.

```
<!--
Обратите внимание, есть ограничения для выражений аргументов
-->
<a v-bind:[attributeName]="url"> ... </a>

<!-- сокращённая запись -->
<a :[attributeName]="url"> ... </a>
```

```
<a v-on:[eventName]="doSomething"> ... </a>

<!-- сокращённая запись -->
<a @[eventName]="doSomething"> ... </a>
```

### Модификаторы

Модификаторы — специальные постфиксы, отделяемые точкой, которые обозначают, что директива 
должна быть привязана каким-то особенным образом. Например, модификатор .prevent даёт указание 
директиве v-on вызвать event.preventDefault() при обработке произошедшего события.

```
<form @submit.prevent="onSubmit">...</form>
```

![Общий синтаксис директив](/directive.png)

## Основы реактивности
​
### Объявление реактивного состояния
​
В Composition API рекомендуемым способом объявления реактивного состояния является использование `ref()`
функции:

```
import { ref } from 'vue'

const count = ref(0)
```

`ref()` принимает аргумент и возвращает его завёрнутым в объект ref со свойством .value:

```
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

Обратите внимание, что нам не нужно добавлять .value при использовании ссылки в шаблоне. 
Для удобства ref автоматически "разворачиваются" при использовании внутри шаблонов:

```
<div>{{ count }}</div>
```

Вы также можете мутировать ref непосредственно в обработчиках событий:

```
<button @click="count++">
  {{ count }}
</button>
```

В однофайловых компонентах инциализация компонента Composition API осуществляется в блоке `<script setup>`:

```
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>
```

### Глубокая реактивность
​
Рефы могут содержать значения любого типа, включая глубоко вложенные объекты, массивы или встроенные в JavaScript структуры данных типа Map.

Ссылка делает своё значение глубоко реактивным. Это означает, что вы можете ожидать обнаружения изменений даже при мутации вложенных объектов или массивов:

```
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // они будут работать, как и ожидалось.
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```

### Время обновления DOM
​
Когда вы изменяете реактивное состояние, DOM обновляется автоматически. Однако следует отметить, что обновления DOM не применяются синхронно. 
Вместо этого Vue буферизирует их до "следующего тика" в цикле обновления, чтобы гарантировать, что каждый компонент обновляется только один раз, 
независимо от того, сколько изменений состояния вы сделали.

Чтобы дождаться завершения обновления DOM после изменения состояния, вы можете использовать глобальный API nextTick():

```
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // Теперь DOM обновлен
}
```
