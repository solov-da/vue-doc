# Справочник Vue 3

https://ru.vuejs.org/guide/introduction.html

## Создание приложения

```
import { createApp } from 'vue'
// импорт корневого компонента App из однофайлового компонента
import App from './App.vue'

const app = createApp(App)
```

В функицию createApp обязательно должен быть передан корневой компонент,
который содержит в себе другие компоненты.


```
<div id="app"></div>

app.mount('#app')

```

Экземпляр приложения не будет ничего отрисовывать, пока не вызвать его метод .mount().

```
app.config.errorHandler = (err) => {
  /* обработка ошибки */
}
```

Экземпляр приложения предоставляет объект .config.

## Синтаксис шаблонов

### Текстовые интерполяции
​
```
<span>Сообщение: {{ msg }}</span>
```

### Сырой HTML
​
```
<p>Директива v-html: <span v-html="rawHtml"></span></p>
```

### Атрибуты

```
<div v-bind:id="dynamicId"></div>
```

```
<div :id="dynamicId"></div>
```

```
<!-- так же, как :id="id" -->
<div :id></div>

<!-- это также работает -->
<div v-bind:id></div>
```

### Булевы атрибуты

```
<button :disabled="isButtonDisabled">Кнопка</button>
```

Атрибут disabled будет добавляться, когда значение isButtonDisabled истинно. 
Он также будет добавляться, если значением будет пустая строка, для сохранения консистентности с <button disabled="">. 
При использовании других ложных значений атрибут будет опущен.

### Динамическая привязка нескольких атрибутов
​
```
data() {
  return {
    objectOfAttrs: {
      id: 'container',
      class: 'wrapper'
    }
  }
}
```

Можно привязать их все к одному элементу, используя v-bind без аргумента:

```
<div v-bind="objectOfAttrs"></div>
```

### Использование JavaScript-выражений

```
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

В шаблонах Vue выражения JavaScript можно использовать в следующих ситуациях:

- Внутри текстовых интерполяций (двойных фигурных скобок)
- В значении атрибутов директив Vue (специальные атрибуты, именуемые с v-)

Каждая привязка может содержать только одно выражение. 
Выражение — часть кода, которая может быть преобразована в значение. 

### Вызов функций
​
```
<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>
```

Функции, вызываемые в выражениях внутри привязки, будут вызываться каждый раз при обновлении компонента, 
поэтому НЕ ДОЛЖНЫ ИМЕТЬ НИКАКИХ ПОБОЧНЫХ ЭФФЕКТОВ, таких как изменение данных или запуск асинхронных операций.

### Ограничения доступа к глобальным объектам
​
Выражения в шаблонах находятся в «песочнице» и имеют доступ только к ограниченному списку глобальных свойств, 
таких как Math и Date.

### Директивы

Директивы — специальные атрибуты с префиксом `v-`.

```
<p v-if="seen">Сейчас меня видно</p>
```

Здесь директива `v-if` удаляет или вставляет на страницу элемент `<p>` на основании истинности выражения `seen`.

Другим примером может быть директива v-on, которая отслеживает события DOM.

```
<a v-on:click="doSomething"> ... </a>

<!-- сокращённая запись -->
<a @click="doSomething"> ... </a>
```

### Динамические аргументы
​
Можно использовать выражение JavaScript в аргументе директивы, для этого потребуется обернуть его в квадратные скобки.

```
<!--
Обратите внимание, есть ограничения для выражений аргументов
-->
<a v-bind:[attributeName]="url"> ... </a>

<!-- сокращённая запись -->
<a :[attributeName]="url"> ... </a>
```

```
<a v-on:[eventName]="doSomething"> ... </a>

<!-- сокращённая запись -->
<a @[eventName]="doSomething"> ... </a>
```

### Модификаторы

Модификаторы — специальные постфиксы, отделяемые точкой, которые обозначают, что директива 
должна быть привязана каким-то особенным образом. Например, модификатор .prevent даёт указание 
директиве v-on вызвать event.preventDefault() при обработке произошедшего события.

```
<form @submit.prevent="onSubmit">...</form>
```

![Общий синтаксис директив](/directive.png)

## Основы реактивности
​
### Объявление реактивного состояния
​
В Composition API рекомендуемым способом объявления реактивного состояния является использование `ref()`
функции:

```
import { ref } from 'vue'

const count = ref(0)
```

`ref()` принимает аргумент и возвращает его завёрнутым в объект ref со свойством .value:

```
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

Обратите внимание, что нам не нужно добавлять .value при использовании ссылки в шаблоне. 
Для удобства ref автоматически "разворачиваются" при использовании внутри шаблонов:

```
<div>{{ count }}</div>
```

Вы также можете мутировать ref непосредственно в обработчиках событий:

```
<button @click="count++">
  {{ count }}
</button>
```

В однофайловых компонентах инциализация компонента Composition API осуществляется в блоке `<script setup>`:

```
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>
```

### Глубокая реактивность
​
Рефы могут содержать значения любого типа, включая глубоко вложенные объекты, массивы или встроенные в JavaScript структуры данных типа Map.

Ссылка делает своё значение глубоко реактивным. Это означает, что вы можете ожидать обнаружения изменений даже при мутации вложенных объектов или массивов:

```
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // они будут работать, как и ожидалось.
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```

### Время обновления DOM
​
Когда вы изменяете реактивное состояние, DOM обновляется автоматически. Однако следует отметить, что обновления DOM не применяются синхронно. 
Вместо этого Vue буферизирует их до "следующего тика" в цикле обновления, чтобы гарантировать, что каждый компонент обновляется только один раз, 
независимо от того, сколько изменений состояния вы сделали.

Чтобы дождаться завершения обновления DOM после изменения состояния, вы можете использовать глобальный API nextTick():

```
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // Теперь DOM обновлен
}
```

## Вычисляемые свойства
​
```
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// ref вычисляемого свойства
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Да' : 'Нет'
})
</script>

<template>
  <p>Есть опубликованные книги:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```

В этом примере объявляем новое вычисляемое свойство publishedBooksMessage. Функция computed() ожидает передачи функции-геттера и возвращает значение в виде ref вычисляемого свойства. Подобно обычным ref-ссылкам, можно получить доступ к вычисленному результату через publishedBooksMessage.value. Вычисляемые свойства в виде ref-ссылок также автоматически разворачиваются в шаблонах, поэтому можно ссылаться на них без .value в выражениях шаблонов.

Вычисляемое свойство автоматически отслеживает свои реактивные зависимости. Vue знает, что publishedBooksMessage зависит от значения author.books, поэтому будет обновлять все привязки, которые зависят от publishedBooksMessage, при изменениях author.books.

## Работа с классами и стилями
​
### Объектный синтаксис

Можно передавать объект в :class (сокращение для v-bind:class) для динамической установки или удаления CSS-классов:

```
<div :class="{ active: isActive }"></div>
```

Синтаксис выше означает, что наличие класса `active` на элементе будет определяться истинностью значения свойства `isActive`,
:class можно использовать совместно с обычным атрибутом class.

### Синтаксис с массивом 

```
const activeClass = ref('active')
const errorClass = ref('text-danger')
```

```
<div :class="[activeClass, errorClass]"></div>
```

Переключать классы в массиве, в зависимости от некоторого условия, можно с помощью условного оператора в форме тернарного выражения:

```
<div :class="[isActive ? activeClass : '', errorClass]"></div>
```

К элементу будет всегда добавляться errorClass, но activeClass — только в случае истинности isActive.

Однако, такая запись начинает выглядеть слегка громоздко, особенно если есть несколько классов, задаваемых по условию. Поэтому возможно использовать и смешанный синтаксис:

```
<div :class="[{ [activeClass]: isActive }, errorClass]"></div>
```

### Использование с компонентами
​
При использовании атрибута class на пользовательском компоненте с одним корневым элементом, классы будут добавлены к этому корневому элементу. 
Существующие классы на этом элементе останутся и не будут перезаписаны.

Например, если возьмём компонент `MyComponent` со следующим шаблоном:

```
<!-- шаблон дочернего компонента -->
<p class="foo bar">Привет</p>
```

Затем добавим на него несколько классов:

```
<!-- при использовании компонента -->
<MyComponent class="baz boo" />
```

То в результате отрисовки получим:

```
<p class="foo bar baz boo">Привет</p>
```

Если у компонента несколько корневых элементов, то потребуется определить какой из них будет получать эти классы. 
Это реализуется добавлением свойства $attrs на элемент:

```
<!-- шаблон MyComponent с использованием $attrs -->
<p :class="$attrs.class">Привет</p>
<span>Это дочерний компонент</span>
```

```
<MyComponent class="baz" />
```

В результате:

```
<p class="baz">Привет</p>
<span>Это дочерний компонент</span>
```

### Привязка инлайн-стилей
​
Объектный синтаксис для :style выглядит почти как для CSS, за исключением того, что это объект JavaScript 
и соответствует свойству style элемента HTML:

```
const activeColor = ref('red')
const fontSize = ref(30)
```

```
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```

Хотя рекомендуется использовать ключи в camelCase, :style также поддерживает ключи CSS-свойств в kebab-case 
(соответствует тому, как они используются в реальном CSS) — например:

```
<div :style="{ 'font-size': fontSize + 'px' }"></div>
```

## Условная отрисовка
​
### v-if

```
<h1 v-if="awesome">Vue восхитителен!</h1>
```

### v-else

```
<button @click="awesome = !awesome">Переключить</button>

<h1 v-if="awesome">Vue восхитителен!</h1>
<h1 v-else>О, нет 😢</h1>
```

### v-else-if

```
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Точно не A, B или C
</div>
```

### Условные группы с помощью v-if и `<template>`
​
Поскольку v-if является директивой, то она должна быть указана на одном элементе. Но что если потребуется управлять отображением 
сразу нескольких элементов? В этом случае можно использовать v-if на элементе <template>, который работает как невидимая 
обёртка и в результатах отрисовки не появится.

```
<template v-if="ok">
  <h1>Заголовок</h1>
  <p>Параграф 1</p>
  <p>Параграф 2</p>
</template>
```

Директивы v-else и v-else-if также можно использовать на <template>.


### v-show
​
Ещё одним вариантом условного отображения является директива v-show. Используется очень похоже:

```
<h1 v-show="ok">Привет!</h1>
```

Отличия в том, что элемент с v-show будет всегда отрисовываться и оставаться в DOM, а переключаться будет лишь его CSS свойство display.

v-show нельзя использовать на элементе <template> и она не работает с v-else.

### v-if или v-show

v-if выполняет «настоящую» условную отрисовку, так как гарантирует, что слушатели событий и 
дочерние компоненты внутри блока должным образом уничтожаются и воссоздаются при переключениях условия.

v-if также ленивый: если условие ложно на момент первоначальной отрисовки, то он ничего не сделает — условный 
блок не будет отрисован до тех пор, пока условие не станет истинным.

Для сравнения, v-show намного проще — элемент всегда отрисовывается, вне зависимости от 
исходного состояния с переключением на основе CSS.

В целом, у v-if выше затраты на переключение, в то время как v-show имеет больше затрат на первичную отрисовку. 
Так что используйте v-show, если переключения будут частыми, и предпочитайте v-if, если условие может и не измениться во время исполнения.

## Отрисовка списков

### Отображение элементов массива через v-for


Используйте директиву v-for для отрисовки списка элементов на основе массива данных. 
У директивы v-for специальный синтаксис: item in items, где items — исходный массив, а item — ссылка на итерируемый элемент массива:
​
```
const items = ref([{ message: 'Foo' }, { message: 'Bar' }])
```

```
<li v-for="item in items">
  {{ item.message }}
</li>
```

Внутри блока v-for доступны все свойства из области видимости родителя. Также может быть второй опциональный параметр у v-for 
с индексом текущего элемента:

```
const parentMessage = ref('Родитель')
const items = ref([{ message: 'Foo' }, { message: 'Bar' }])
```

```
<li v-for="(item, index) in items">
  {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>
```


### Отображение свойств объекта через v-for

Также можно использовать v-for для итерирования по свойствам объекта. При итерации по объекту порядок обхода свойств будет как и в Object.keys():

```
const myObject = reactive({
  title: 'How to do lists in Vue',
  author: 'Jane Doe',
  publishedAt: '2016-04-10'
})
```

```
<ul>
  <li v-for="value in myObject">
    {{ value }}
  </li>
</ul>
```

Можно указать второй аргумент для получения имени свойства (ключа объекта):

```
<li v-for="(value, key) in myObject">
  {{ key }}: {{ value }}
</li>
```

И третий — для индекса:

```
<li v-for="(value, key, index) in myObject">
  {{ index }}. {{ key }}: {{ value }}
</li>
```

### v-for и диапазоны

Можно передавать целое число в v-for — шаблон будет повторяться указанное число раз.
​
```
<span v-for="n in 10">{{ n }}</span>
```

Обратите внимание, что в таком случае значения n начинаются с 1, а не с 0.

### v-for и <template>
​

Аналогично использованию с v-if, также можно использовать тег <template> с директивой v-for для отрисовки блоков 
из нескольких элементов. Например:

```
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```

### Сохранение состояния с помощью key
​

Чтобы подсказать Vue, как определять идентичность каждого элемента, и, таким образом, переиспользовать и упорядочивать существующие элементы, 
необходимо указать уникальный атрибут key для каждого элемента:

```
<div v-for="item in items" :key="item.id">
  <!-- Содержимое -->
</div>
```

При использовании <template v-for> атрибут key нужно устанавливать на контейнер <template>:

```
<template v-for="todo in todos" :key="todo.name">
  <li>{{ todo.name }}</li>
</template>
```

### v-for и компоненты
​
Можно использовать v-for на компонентах, как на обычных элементах (не забывайте указать key):

```
<MyComponent v-for="item in items" :key="item.id" />
```

Однако в компонент никакие данные автоматически передаваться не будут, поскольку у каждого будет своя изолированная область видимости. 
Чтобы передать итерируемые данные в компонент потребуется явно использовать входные параметры:

```
<MyComponent
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
/>
```

Причина, почему не происходит автоматической передачи item в компонент заключается в том, что это сделает компонент жёстко связанным с тем, 
как работает v-for. Но явное указание на то, откуда поступают данные, позволит переиспользовать и в других ситуациях.

### Отслеживание изменений в массивах
​
Vue способен определять, когда вызываются методы мутации реактивного массива, и запускать необходимые обновления. К таким мутирующим методам относятся:

    push()
    pop()
    shift()
    unshift()
    splice()
    sort()
    reverse()

Методы, мутирующие массив, как следует из названия, будут изменять исходный массив, на котором они вызваны. 
Но есть и другие, например filter(), concat() и slice(), которые не мутируют исходный массив, а всегда возвращают новый массив. 
При их использовании можно просто заменять старый массив на новый

```
// `items` это ref-ссылка с массивом в значении
items.value = items.value.filter((item) => item.message.match(/Foo/))
```

### Отображение отфильтрованных/отсортированных результатов
​
Иногда может потребоваться отображать отфильтрованную или отсортированную версию массива, сохранив оригинальные данные. 
В таком случае можно создать вычисляемое свойство, которое будет возвращать отфильтрованный или отсортированный массив.

```
const numbers = ref([1, 2, 3, 4, 5])

const evenNumbers = computed(() => {
  return numbers.value.filter((n) => n % 2 === 0)
})
```

```
<li v-for="n in evenNumbers">{{ n }}</li>
```

В ситуациях, когда вычисляемые свойства невозможно применить (например, внутри вложенных циклов v-for), можно использовать метод:

```
const sets = ref([
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10]
])

function even(numbers) {
  return numbers.filter((number) => number % 2 === 0)
}
```

```
<ul v-for="numbers in sets">
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>
```

Обратите внимание на использование reverse() и sort() в вычисляемых свойствах! 
Эти два метода изменят исходный массив, а этого следует избегать в геттерах вычисляемых свойств.

## Обработка событий
​
### Прослушивание событий
​
Можно использовать директиву v-on, которую обычно сокращают до символа @, чтобы прослушивать события DOM и запускать JavaScript-код по их наступлению. Используется как `v-on:click="methodName"` или в сокращённом виде `@click="methodName"`.

Значение обработчика может быть одним из следующих:

1. Обработчик события в виде инлайн-кода: Код JavaScript будет выполняться при срабатывании события (аналогично как в нативном атрибуте onclick).

2. Обработчик события в виде метода: Имя свойства или путь, указывающий на метод, объявленный в компоненте.

### Обработчик события в виде инлайн-кода

Обычно подобный подход используют лишь в очень простых случаях, например:
​
```
const count = ref(0)
```

```
<button @click="count++">Добавить 1</button>
<p>Счётчик: {{ count }}</p>
```

### Обработчик события в виде метода
​
Но чаще всего у многих обработчиков событий логика будет довольно сложной, 
поэтому оставлять JavaScript-код в значении атрибута v-on бессмысленно. 
Поэтому v-on также принимает имя метода, который потребуется вызвать.

```
const name = ref('Vue.js')

function greet(event) {
  alert(`Привет, ${name.value}!`)
  // `event` — нативное событие DOM
  if (event) {
    alert(event.target.tagName)
  }
}
```

```
<!-- `greet` — название метода, объявленного в компоненте выше -->
<button @click="greet">Поприветствовать</button>
```

Метод обработчика автоматически получает аргументом нативное событие DOM, которое его вызвало — например, 
в примере выше можно получить доступ к элементу, на котором произошло событие, через `event.target`.

### Вызов методов в инлайн-обработчиках

Вместо привязки непосредственно к имени метода, можно вызывать методы и в инлайн-обработчике. 
Это позволит передавать в метод вместо нативного события другие аргументы:

```
function say(message) {
  alert(message)
}
```

```
<button @click="say('привет')">Скажи привет</button>
<button @click="say('пока')">Скажи пока</button>
```
​
### Доступ к событию через аргумент в инлайн-обработчиках
​
Иногда может потребоваться получить доступ к оригинальному событию DOM в инлайн-обработчике. 
Его можно явно передать в метод с помощью специальной переменной $event или воспользоваться стрелочной функцией:

```
<!-- использование специальной переменной $event -->
<button @click="warn('Форму пока ещё нельзя отправить.', $event)">
  Отправить
</button>

<!-- использование стрелочной функции в инлайн-выражении -->
<button @click="(event) => warn('Форму пока ещё нельзя отправить.', event)">
  Отправить
</button>
```

```
function warn(message, event) {
  // теперь есть доступ к нативному событию
  if (event) {
    event.preventDefault()
  }
  alert(message)
}
```

### Модификаторы событий
​
    .stop
    .prevent
    .self
    .capture
    .once
    .passive

### Модификаторы клавиш

```
<!-- вызвать `vm.submit()` только если `key` клавиши будет `Enter` -->
<input @keyup.enter="submit" />
```

    .enter
    .tab
    .delete (ловит как «Delete», так и «Backspace»)
    .esc
    .space
    .up
    .down
    .left
    .right

### Модификаторы системных клавиш
​
    .ctrl
    .alt
    .shift
    .meta

Модификатор .exact позволяет контролировать точную комбинацию модификаторов системных клавиш, необходимых для запуска события.

### Модификаторы кнопок мыши
​
    .left
    .right
    .middle

## Работа с формами
​
При работе с формами часто требуется синхронизировать состояния элементов ввода в форме с соответствующим состоянием в JavaScript. 

```
<input
  :value="text"
  @input="event => text = event.target.value"
>
```

Директива v-model помогает упростить указанное выше до:

```
<input v-model="text">
```

### Текст

```
<p>Сообщение: {{ message }}</p>
<input v-model="message" placeholder="отредактируй меня" />
```

### Многострочный текст
​
```
<span>Многострочное сообщение:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<textarea v-model="message" placeholder="введите несколько строчек"></textarea>
```

### Чекбоксы

Один чекбокс, привязанный к булевому значению:

```
<input type="checkbox" id="checkbox" v-model="checked" />
<label for="checkbox">{{ checked }}</label>
```

Список чекбоксов, привязанных к массиву или значениям Set:

```
const checkedNames = ref([])
```

```
<div>Отмеченные имена: {{ checkedNames }}</div>

<input type="checkbox" id="jack" value="Jack" v-model="checkedNames" />
<label for="jack">Jack</label>

<input type="checkbox" id="john" value="John" v-model="checkedNames" />
<label for="john">John</label>

<input type="checkbox" id="mike" value="Mike" v-model="checkedNames" />
<label for="mike">Mike</label>
```

### Радиокнопки

```
<div>Выбрано: {{ picked }}</div>

<input type="radio" id="one" value="Один" v-model="picked" />
<label for="one">Один</label>

<input type="radio" id="two" value="Два" v-model="picked" />
<label for="two">Два</label>
```

### Выпадающие списки
​
Выбор одного варианта из списка:

```
<div>Выбрано: {{ selected }}</div>

<select v-model="selected">
  <option disabled value="">Выберите один из вариантов</option>
  <option>А</option>
  <option>Б</option>
  <option>В</option>
</select>
```

Выбор нескольких вариантов из списка (с привязкой к массиву):

```
<div>Выбраны: {{ selected }}</div>

<select v-model="selected" multiple>
  <option>А</option>
  <option>Б</option>
  <option>В</option>
</select>
```

Динамическое отображение списка опций с помощью v-for:

```
const selected = ref('A')

const options = ref([
  { text: 'Один', value: 'A' },
  { text: 'Два', value: 'B' },
  { text: 'Три', value: 'C' }
])
```

```
<select v-model="selected">
  <option v-for="option in options" :value="option.value">
    {{ option.text }}
  </option>
</select>

<div>Выбрано: {{ selected }}</div>
```

### Привязка значений
​
```
<!-- `picked` будет строкой "a" при выборе -->
<input type="radio" v-model="picked" value="a" />

<!-- `toggle` может принимать значение true или false -->
<input type="checkbox" v-model="toggle" />

<!-- `selected` будет строкой "abc" при выборе первого пункта -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
```

### Чекбокс

```
<input
  type="checkbox"
  v-model="toggle"
  true-value="да"
  false-value="нет" />
```

Атрибуты true-value и false-value — специальные атрибуты Vue, которые работают только в связке с v-model. 
Здесь значение свойства toggle будет установлено в 'да', когда чекбокс выбран, и в 'нет' когда сброшен. 
Также можно привязать их к динамическим значением с помощью v-bind:

```
<input
  type="checkbox"
  v-model="toggle"
  :true-value="dynamicTrueValue"
  :false-value="dynamicFalseValue" />
```

### Радиокнопки

```
<input type="radio" v-model="pick" :value="first" />
<input type="radio" v-model="pick" :value="second" />
```

Значение pick будет установлено в first при выборе первой радиокнопки, и в значение second при выборе второй.


### Выпадающие списки
​
```
<select v-model="selected">
  <!-- инлайновый объект с данными -->
  <option :value="{ number: 123 }">123</option>
</select>
```

Директива v-model поддерживает привязку и нестроковых значений! В примере выше, когда опция выбрана, 
значение selected будет объектом { number: 123 }.

### Модификаторы

По умолчанию v-model синхронизирует поле ввода с данными по событию input (кроме вышеупомянутых исключений для композиции IME). 
Можно воспользоваться модификатором lazy, чтобы синхронизация происходила по событию change:

```
<!-- синхронизация после события "change" вместо "input" -->
<input v-model.lazy="msg" />
```

Для автоматического приведения введённого пользователем к числу можно добавить модификатор number:

```
<input v-model.number="age" />
```

Если значение не получится привести к числу с помощью parseFloat(), то будет возвращено исходное значение.
Модификатор number автоматически применяется к полям type="number".

Если необходимо автоматически удалять пробельные символы в начале и в конце строки, можно добавить модификатор trim:

```
<input v-model.trim="msg" />
```

## Хуки жизненного цикла

![Диаграмма жизненного цикла](/lifecycle.png)
​

