# Справочник Vue 3

https://ru.vuejs.org/guide/introduction.html

## Создание приложения

```
import { createApp } from 'vue'
// импорт корневого компонента App из однофайлового компонента
import App from './App.vue'

const app = createApp(App)
```

В функицию createApp обязательно должен быть передан корневой компонент,
который содержит в себе другие компоненты.


```
<div id="app"></div>

app.mount('#app')

```

Экземпляр приложения не будет ничего отрисовывать, пока не вызвать его метод .mount().

```
app.config.errorHandler = (err) => {
  /* обработка ошибки */
}
```

Экземпляр приложения предоставляет объект .config.

## Синтаксис шаблонов

### Текстовые интерполяции
​
```
<span>Сообщение: {{ msg }}</span>
```

### Сырой HTML
​
```
<p>Директива v-html: <span v-html="rawHtml"></span></p>
```

### Атрибуты

```
<div v-bind:id="dynamicId"></div>
```

```
<div :id="dynamicId"></div>
```

```
<!-- так же, как :id="id" -->
<div :id></div>

<!-- это также работает -->
<div v-bind:id></div>
```

### Булевы атрибуты

```
<button :disabled="isButtonDisabled">Кнопка</button>
```

Атрибут disabled будет добавляться, когда значение isButtonDisabled истинно. 
Он также будет добавляться, если значением будет пустая строка, для сохранения консистентности с <button disabled="">. 
При использовании других ложных значений атрибут будет опущен.

### Динамическая привязка нескольких атрибутов
​
```
data() {
  return {
    objectOfAttrs: {
      id: 'container',
      class: 'wrapper'
    }
  }
}
```

Можно привязать их все к одному элементу, используя v-bind без аргумента:

```
<div v-bind="objectOfAttrs"></div>
```

### Использование JavaScript-выражений

```
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

В шаблонах Vue выражения JavaScript можно использовать в следующих ситуациях:

- Внутри текстовых интерполяций (двойных фигурных скобок)
- В значении атрибутов директив Vue (специальные атрибуты, именуемые с v-)

Каждая привязка может содержать только одно выражение. 
Выражение — часть кода, которая может быть преобразована в значение. 

### Вызов функций
​
```
<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>
```

Функции, вызываемые в выражениях внутри привязки, будут вызываться каждый раз при обновлении компонента, 
поэтому НЕ ДОЛЖНЫ ИМЕТЬ НИКАКИХ ПОБОЧНЫХ ЭФФЕКТОВ, таких как изменение данных или запуск асинхронных операций.

### Ограничения доступа к глобальным объектам
​
Выражения в шаблонах находятся в «песочнице» и имеют доступ только к ограниченному списку глобальных свойств, 
таких как Math и Date.

### Директивы

Директивы — специальные атрибуты с префиксом `v-`.

```
<p v-if="seen">Сейчас меня видно</p>
```

Здесь директива `v-if` удаляет или вставляет на страницу элемент `<p>` на основании истинности выражения `seen`.

Другим примером может быть директива v-on, которая отслеживает события DOM.

```
<a v-on:click="doSomething"> ... </a>

<!-- сокращённая запись -->
<a @click="doSomething"> ... </a>
```

### Динамические аргументы
​
Можно использовать выражение JavaScript в аргументе директивы, для этого потребуется обернуть его в квадратные скобки.

```
<!--
Обратите внимание, есть ограничения для выражений аргументов
-->
<a v-bind:[attributeName]="url"> ... </a>

<!-- сокращённая запись -->
<a :[attributeName]="url"> ... </a>
```

```
<a v-on:[eventName]="doSomething"> ... </a>

<!-- сокращённая запись -->
<a @[eventName]="doSomething"> ... </a>
```

### Модификаторы

Модификаторы — специальные постфиксы, отделяемые точкой, которые обозначают, что директива 
должна быть привязана каким-то особенным образом. Например, модификатор .prevent даёт указание 
директиве v-on вызвать event.preventDefault() при обработке произошедшего события.

```
<form @submit.prevent="onSubmit">...</form>
```

![Общий синтаксис директив](/directive.png)

## Основы реактивности
​
### Объявление реактивного состояния
​
В Composition API рекомендуемым способом объявления реактивного состояния является использование `ref()`
функции:

```
import { ref } from 'vue'

const count = ref(0)
```

`ref()` принимает аргумент и возвращает его завёрнутым в объект ref со свойством .value:

```
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

Обратите внимание, что нам не нужно добавлять .value при использовании ссылки в шаблоне. 
Для удобства ref автоматически "разворачиваются" при использовании внутри шаблонов:

```
<div>{{ count }}</div>
```

Вы также можете мутировать ref непосредственно в обработчиках событий:

```
<button @click="count++">
  {{ count }}
</button>
```

В однофайловых компонентах инциализация компонента Composition API осуществляется в блоке `<script setup>`:

```
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>
```

### Глубокая реактивность
​
Рефы могут содержать значения любого типа, включая глубоко вложенные объекты, массивы или встроенные в JavaScript структуры данных типа Map.

Ссылка делает своё значение глубоко реактивным. Это означает, что вы можете ожидать обнаружения изменений даже при мутации вложенных объектов или массивов:

```
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // они будут работать, как и ожидалось.
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```

### Время обновления DOM
​
Когда вы изменяете реактивное состояние, DOM обновляется автоматически. Однако следует отметить, что обновления DOM не применяются синхронно. 
Вместо этого Vue буферизирует их до "следующего тика" в цикле обновления, чтобы гарантировать, что каждый компонент обновляется только один раз, 
независимо от того, сколько изменений состояния вы сделали.

Чтобы дождаться завершения обновления DOM после изменения состояния, вы можете использовать глобальный API nextTick():

```
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // Теперь DOM обновлен
}
```

## Вычисляемые свойства
​
```
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// ref вычисляемого свойства
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Да' : 'Нет'
})
</script>

<template>
  <p>Есть опубликованные книги:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```

В этом примере объявляем новое вычисляемое свойство publishedBooksMessage. Функция computed() ожидает передачи функции-геттера и возвращает значение в виде ref вычисляемого свойства. Подобно обычным ref-ссылкам, можно получить доступ к вычисленному результату через publishedBooksMessage.value. Вычисляемые свойства в виде ref-ссылок также автоматически разворачиваются в шаблонах, поэтому можно ссылаться на них без .value в выражениях шаблонов.

Вычисляемое свойство автоматически отслеживает свои реактивные зависимости. Vue знает, что publishedBooksMessage зависит от значения author.books, поэтому будет обновлять все привязки, которые зависят от publishedBooksMessage, при изменениях author.books.

## Работа с классами и стилями
​
### Объектный синтаксис

Можно передавать объект в :class (сокращение для v-bind:class) для динамической установки или удаления CSS-классов:

```
<div :class="{ active: isActive }"></div>
```

Синтаксис выше означает, что наличие класса `active` на элементе будет определяться истинностью значения свойства `isActive`,
:class можно использовать совместно с обычным атрибутом class.

### Синтаксис с массивом 

```
const activeClass = ref('active')
const errorClass = ref('text-danger')
```

```
<div :class="[activeClass, errorClass]"></div>
```

Переключать классы в массиве, в зависимости от некоторого условия, можно с помощью условного оператора в форме тернарного выражения:

```
<div :class="[isActive ? activeClass : '', errorClass]"></div>
```

К элементу будет всегда добавляться errorClass, но activeClass — только в случае истинности isActive.

Однако, такая запись начинает выглядеть слегка громоздко, особенно если есть несколько классов, задаваемых по условию. Поэтому возможно использовать и смешанный синтаксис:

```
<div :class="[{ [activeClass]: isActive }, errorClass]"></div>
```

### Использование с компонентами
​
При использовании атрибута class на пользовательском компоненте с одним корневым элементом, классы будут добавлены к этому корневому элементу. 
Существующие классы на этом элементе останутся и не будут перезаписаны.

Например, если возьмём компонент `MyComponent` со следующим шаблоном:

```
<!-- шаблон дочернего компонента -->
<p class="foo bar">Привет</p>
```

Затем добавим на него несколько классов:

```
<!-- при использовании компонента -->
<MyComponent class="baz boo" />
```

То в результате отрисовки получим:

```
<p class="foo bar baz boo">Привет</p>
```

Если у компонента несколько корневых элементов, то потребуется определить какой из них будет получать эти классы. 
Это реализуется добавлением свойства $attrs на элемент:

```
<!-- шаблон MyComponent с использованием $attrs -->
<p :class="$attrs.class">Привет</p>
<span>Это дочерний компонент</span>
```

```
<MyComponent class="baz" />
```

В результате:

```
<p class="baz">Привет</p>
<span>Это дочерний компонент</span>
```

### Привязка инлайн-стилей
​
Объектный синтаксис для :style выглядит почти как для CSS, за исключением того, что это объект JavaScript 
и соответствует свойству style элемента HTML:

```
const activeColor = ref('red')
const fontSize = ref(30)
```

```
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```

Хотя рекомендуется использовать ключи в camelCase, :style также поддерживает ключи CSS-свойств в kebab-case 
(соответствует тому, как они используются в реальном CSS) — например:

```
<div :style="{ 'font-size': fontSize + 'px' }"></div>
```